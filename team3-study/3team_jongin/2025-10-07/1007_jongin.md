# 1007 공부내용 📖

## 매일매일 1일 면접 대비

### **useEffect를 이용하여 로딩 상태 관리하는 방법과 Suspense를 활용하는 방법에 대한 차이점을 설명해주세요.**
```suspense```와 기존 로딩 상태 관리 방식인 ```useEffect()```와 loading state는 로딩 상태 관리를 관리하는 방식에서 근본적인 차이가 있다. 기존 방식에서는 데이터를 불러 올때 ```useEffect()``` 훅을 사용하고, 로딩 상태를 관리하기 위해 ```isLoading```이라는 별도의 상태 변수를 만들어야 한다. 예를 들어 데이터를 불러오는 동안에는 ```isLoading```을 ```true```로 설정하고, 데이터가 다 불러온다면 ```false```로 바꾸는 식이다. 그래서 조건에 따라 로딩 UI를 보여주시는 식으로 동작한다. 이 방식은 간단한 상황에서는 충분히 유효하지만, 여러 개의 비동기 데이터를 다룰 때에는 조건부 랜더링 로직이 복잡해질 수 있다.

반면 ```suspense```는 로딩중인 컴포넌트를 직접 랜더링하지 않고, ```suspense```컴포넌트의 ```fallback```속성으로 로딩 UI를 정의하게끔 한다. 데이터를 기다리는 동안에는 ```fallback```으로 정의된 UI만 보여주고, 데이터가 모두 준비되면 ```suspense```에 감싸진 컴포넌트를 자연스럽게 표시한다. 이렇게 로딩 상태를 선언적으로 관리할수 있기 때문에 전체적인 코드가 단순해지고 유지보수도 쉬워진다.

### Suspense의 단점은 무엇일까?
여러 개의 ```suspense```컴포넌트를 중첩하거나 트리 구조로 사용할 경우, 각 ```suspense```가 독립적으로 로딩 상태를 관리하기 때문에 데이터 준비 시점이 다를 수 있다. 그 결과 로딩 화면(fallback)이 여러번 표시되거나 비일관적인 UI 경험이 발생할 수 있다. 이를 적절히 제어하기 위해서는 트리의 구조와 데이터 로딩 흐름을 신중하게 설계해야 한다.

또한 ```suspense```는 ```Promise```기반의 비동기 작업만 지원한다. 따라서 일반적인 ```fetch```요청에 바로 적용할 수 있는 것이 아니라, 이를 위해 추가적인 라이브러리를 이용하거나 ```suspense```와 호환되는 형태로 ```promise```를 관리해야한다.
## 오늘의 알고리즘 문제

### 1번 문제

```js

```

### 2번 문제

```js

```

## 리액트 시리즈
